# 双人对抗单词闯关游戏 - 技术文档 - 第2部分

### 5. 小游戏引擎模块 (Minigame Engine)

#### 小游戏抽象接口
```typescript
// 小游戏基础接口
interface Minigame {
  id: string
  name: string
  description: string
  maxPlayers: number
  initialize(players: Player[]): MinigameState
  updateState(state: MinigameState, playerId: string, isCorrect: boolean): MinigameState
  checkWinner(state: MinigameState): string | null
  getVisualState(state: MinigameState): any
}

// 小游戏状态
interface MinigameState {
  gameId: string
  players: MinigamePlayer[]
  gameData: any // 游戏特定数据
  isFinished: boolean
  winner?: string
  startTime: Date
  lastUpdateTime: Date
}

interface MinigamePlayer {
  userId: string
  position: number
  score: number
  status: 'active' | 'eliminated' | 'winner'
  gameSpecificData: any
}
```

#### 具体小游戏实现示例

##### 1. 警察抓小偷游戏
```typescript
class CopAndThiefGame implements Minigame {
  id = 'cop-and-thief'
  name = '警察抓小偷'
  description = '警察追捕小偷，答对前进，答错后退'
  maxPlayers = 2

  initialize(players: Player[]): MinigameState {
    return {
      gameId: this.id,
      players: players.map((player, index) => ({
        userId: player.userId,
        position: 0, // 起始位置
        score: 0,
        status: 'active',
        gameSpecificData: {
          role: index === 0 ? 'cop' : 'thief',
          steps: 0
        }
      })),
      gameData: {
        trackLength: 20, // 跑道长度
        copPosition: 0,
        thiefPosition: 0,
        safeZone: 20 // 小偷安全区
      },
      isFinished: false,
      startTime: new Date(),
      lastUpdateTime: new Date()
    }
  }

  updateState(state: MinigameState, playerId: string, isCorrect: boolean): MinigameState {
    const player = state.players.find(p => p.userId === playerId)
    if (!player || state.isFinished) return state

    const isCop = player.gameSpecificData.role === 'cop'
    const movement = isCorrect ? 1 : -1

    if (isCop) {
      // 警察移动
      state.gameData.copPosition = Math.max(0, state.gameData.copPosition + movement)
    } else {
      // 小偷移动
      state.gameData.thiefPosition = Math.max(0, state.gameData.thiefPosition + movement)
    }

    // 更新玩家位置
    player.position = isCop ? state.gameData.copPosition : state.gameData.thiefPosition
    player.gameSpecificData.steps++

    // 检查游戏结束条件
    if (state.gameData.copPosition >= state.gameData.thiefPosition) {
      // 警察抓到小偷
      state.isFinished = true
      state.winner = state.players.find(p => p.gameSpecificData.role === 'cop')?.userId
    } else if (state.gameData.thiefPosition >= state.gameData.safeZone) {
      // 小偷逃脱
      state.isFinished = true
      state.winner = state.players.find(p => p.gameSpecificData.role === 'thief')?.userId
    }

    state.lastUpdateTime = new Date()
    return state
  }

  checkWinner(state: MinigameState): string | null {
    return state.winner || null
  }

  getVisualState(state: MinigameState): any {
    return {
      trackLength: state.gameData.trackLength,
      copPosition: state.gameData.copPosition,
      thiefPosition: state.gameData.thiefPosition,
      safeZone: state.gameData.safeZone,
      players: state.players.map(p => ({
        userId: p.userId,
        role: p.gameSpecificData.role,
        position: p.position,
        steps: p.gameSpecificData.steps
      }))
    }
  }
}
```

##### 2. 登天梯游戏
```typescript
class TowerClimbGame implements Minigame {
  id = 'tower-climb'
  name = '登天梯'
  description = '攀爬天梯，答对上升2层，答错下降3层'
  maxPlayers = 4

  initialize(players: Player[]): MinigameState {
    return {
      gameId: this.id,
      players: players.map(player => ({
        userId: player.userId,
        position: 0,
        score: 0,
        status: 'active',
        gameSpecificData: {
          height: 0
        }
      })),
      gameData: {
        towerHeight: 20,
        winHeight: 20
      },
      isFinished: false,
      startTime: new Date(),
      lastUpdateTime: new Date()
    }
  }

  updateState(state: MinigameState, playerId: string, isCorrect: boolean): MinigameState {
    const player = state.players.find(p => p.userId === playerId)
    if (!player || state.isFinished) return state

    if (isCorrect) {
      // 答对：上升2层
      player.gameSpecificData.height += 2
    } else {
      // 答错：下降3层，最低0层
      player.gameSpecificData.height = Math.max(0, player.gameSpecificData.height - 3)
    }

    player.position = player.gameSpecificData.height

    // 检查是否有玩家到达顶端
    if (player.gameSpecificData.height >= state.gameData.winHeight) {
      state.isFinished = true
      state.winner = playerId
    }

    state.lastUpdateTime = new Date()
    return state
  }

  checkWinner(state: MinigameState): string | null {
    return state.winner || null
  }

  getVisualState(state: MinigameState): any {
    return {
      towerHeight: state.gameData.towerHeight,
      players: state.players.map(p => ({
        userId: p.userId,
        height: p.gameSpecificData.height
      }))
    }
  }
}
```

##### 3. 词力拔河游戏
```typescript
class TugOfWarGame implements Minigame {
  id = 'tug-of-war'
  name = '词力拔河'
  description = '拔河比赛，答对拉绳，答错对方得利'
  maxPlayers = 2

  initialize(players: Player[]): MinigameState {
    return {
      gameId: this.id,
      players: players.map((player, index) => ({
        userId: player.userId,
        position: 0,
        score: 0,
        status: 'active',
        gameSpecificData: {
          side: index === 0 ? 'left' : 'right',
          pullPower: 0
        }
      })),
      gameData: {
        ropePosition: 0, // -10到10，负数表示左边获胜，正数表示右边获胜
        winThreshold: 8
      },
      isFinished: false,
      startTime: new Date(),
      lastUpdateTime: new Date()
    }
  }

  updateState(state: MinigameState, playerId: string, isCorrect: boolean): MinigameState {
    const player = state.players.find(p => p.userId === playerId)
    if (!player || state.isFinished) return state

    const pullDirection = player.gameSpecificData.side === 'left' ? -1 : 1
    const pullStrength = isCorrect ? 2 : -1 // 答对拉2格，答错对方得1格

    state.gameData.ropePosition += pullDirection * pullStrength

    // 限制绳子位置范围
    state.gameData.ropePosition = Math.max(-10, Math.min(10, state.gameData.ropePosition))

    // 检查胜负
    if (Math.abs(state.gameData.ropePosition) >= state.gameData.winThreshold) {
      state.isFinished = true
      if (state.gameData.ropePosition <= -state.gameData.winThreshold) {
        state.winner = state.players.find(p => p.gameSpecificData.side === 'left')?.userId
      } else {
        state.winner = state.players.find(p => p.gameSpecificData.side === 'right')?.userId
      }
    }

    state.lastUpdateTime = new Date()
    return state
  }

  checkWinner(state: MinigameState): string | null {
    return state.winner || null
  }

  getVisualState(state: MinigameState): any {
    return {
      ropePosition: state.gameData.ropePosition,
      winThreshold: state.gameData.winThreshold,
      players: state.players.map(p => ({
        userId: p.userId,
        side: p.gameSpecificData.side
      }))
    }
  }
}
```

#### 小游戏引擎管理器
```typescript
class MinigameEngine {
  private games: Map<string, Minigame> = new Map()

  constructor() {
    this.registerGames()
  }

  private registerGames() {
    const games = [
      new CopAndThiefGame(),
      new TowerClimbGame(),
      new TugOfWarGame(),
      // ... 其他小游戏
    ]

    games.forEach(game => {
      this.games.set(game.id, game)
    })
  }

  getRandomGame(playerCount: number): Minigame {
    const availableGames = Array.from(this.games.values())
      .filter(game => game.maxPlayers >= playerCount)

    const randomIndex = Math.floor(Math.random() * availableGames.length)
    return availableGames[randomIndex]
  }

  initializeMinigame(gameId: string, players: Player[]): MinigameState {
    const game = this.games.get(gameId)
    if (!game) throw new Error(`未找到游戏: ${gameId}`)

    return game.initialize(players)
  }

  updateGameState(state: MinigameState, playerId: string, isCorrect: boolean): MinigameState {
    const game = this.games.get(state.gameId)
    if (!game) throw new Error(`未找到游戏: ${state.gameId}`)

    return game.updateState(state, playerId, isCorrect)
  }
}
```

### 6. 数据库设计

#### 数据库表结构
```sql
-- 用户表
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    nickname VARCHAR(50) UNIQUE NOT NULL,
    avatar VARCHAR(255),
    grade VARCHAR(20) NOT NULL,
    level INTEGER DEFAULT 1,
    exp INTEGER DEFAULT 0,
    coins INTEGER DEFAULT 100,
    win_rate DECIMAL(5,2) DEFAULT 0.00,
    total_games INTEGER DEFAULT 0,
    wechat_open_id VARCHAR(100) UNIQUE,
    qq_open_id VARCHAR(100) UNIQUE,
    is_guest BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login_at TIMESTAMP
);

-- 好友关系表
CREATE TABLE friendships (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    friend_id UUID REFERENCES users(id) ON DELETE CASCADE,
    status VARCHAR(20) DEFAULT 'pending', -- pending, accepted, blocked
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    accepted_at TIMESTAMP,
    UNIQUE(user_id, friend_id)
);

-- 游戏记录表
CREATE TABLE game_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    room_id VARCHAR(50) NOT NULL,
    player1_id UUID REFERENCES users(id),
    player2_id UUID REFERENCES users(id),
    winner_id UUID REFERENCES users(id),
    game_mode VARCHAR(20) NOT NULL, -- quick, ranked, friend
    grade VARCHAR(20) NOT NULL,
    total_questions INTEGER NOT NULL,
    duration_seconds INTEGER NOT NULL,
    minigames JSONB NOT NULL, -- 存储每关的小游戏信息
    started_at TIMESTAMP NOT NULL,
    finished_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 玩家游戏详情表
CREATE TABLE player_game_details (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    game_record_id UUID REFERENCES game_records(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id),
    level1_score INTEGER DEFAULT 0,
    level2_score INTEGER DEFAULT 0,
    level3_score INTEGER DEFAULT 0,
    total_score INTEGER DEFAULT 0,
    correct_answers INTEGER DEFAULT 0,
    wrong_answers INTEGER DEFAULT 0,
    average_response_time DECIMAL(8,2),
    exp_gained INTEGER DEFAULT 0,
    coins_gained INTEGER DEFAULT 0
);

-- 答题记录表
CREATE TABLE answer_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    game_record_id UUID REFERENCES game_records(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id),
    level INTEGER NOT NULL,
    question_id VARCHAR(100) NOT NULL,
    question_text VARCHAR(255) NOT NULL,
    correct_answer VARCHAR(255) NOT NULL,
    user_answer VARCHAR(255),
    is_correct BOOLEAN NOT NULL,
    response_time_ms INTEGER NOT NULL,
    answered_at TIMESTAMP NOT NULL
);

-- 成就表
CREATE TABLE achievements (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL,
    description TEXT NOT NULL,
    icon VARCHAR(255),
    condition_type VARCHAR(50) NOT NULL, -- total_games, win_streak, correct_answers, etc.
    condition_value INTEGER NOT NULL,
    reward_exp INTEGER DEFAULT 0,
    reward_coins INTEGER DEFAULT 0,
    reward_items JSONB,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 用户成就表
CREATE TABLE user_achievements (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    achievement_id UUID REFERENCES achievements(id),
    progress INTEGER DEFAULT 0,
    is_completed BOOLEAN DEFAULT false,
    completed_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user_id, achievement_id)
);

-- 商店物品表
CREATE TABLE shop_items (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL,
    description TEXT,
    category VARCHAR(50) NOT NULL, -- avatar, skin, prop, privilege
    price INTEGER NOT NULL,
    currency VARCHAR(20) DEFAULT 'coins', -- coins, real_money
    image_url VARCHAR(255),
    is_available BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 用户物品表
CREATE TABLE user_items (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    item_id UUID REFERENCES shop_items(id),
    quantity INTEGER DEFAULT 1,
    is_equipped BOOLEAN DEFAULT false,
    purchased_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user_id, item_id)
);

-- 排行榜表（可以用视图实现）
CREATE VIEW leaderboard AS
SELECT
    u.id,
    u.nickname,
    u.avatar,
    u.grade,
    u.level,
    u.win_rate,
    u.total_games,
    ROW_NUMBER() OVER (ORDER BY u.win_rate DESC, u.total_games DESC) as rank
FROM users u
WHERE u.total_games >= 10 -- 至少玩过10局才能上榜
ORDER BY u.win_rate DESC, u.total_games DESC;
```

#### Redis缓存设计
```typescript
// Redis键命名规范
const RedisKeys = {
  // 用户相关
  USER_SESSION: (userId: string) => `user:session:${userId}`,
  USER_ONLINE: (userId: string) => `user:online:${userId}`,
  USER_FRIENDS: (userId: string) => `user:friends:${userId}`,

  // 匹配队列
  MATCHING_QUEUE: (grade: string) => `matching:queue:${grade}`,
  MATCHING_USER: (userId: string) => `matching:user:${userId}`,

  // 游戏房间
  GAME_ROOM: (roomId: string) => `game:room:${roomId}`,
  ROOM_PLAYERS: (roomId: string) => `game:room:players:${roomId}`,

  // 排行榜缓存
  LEADERBOARD_WEEKLY: 'leaderboard:weekly',
  LEADERBOARD_MONTHLY: 'leaderboard:monthly',
  LEADERBOARD_ALL_TIME: 'leaderboard:all_time',

  // 统计数据
  STATS_DAILY: (date: string) => `stats:daily:${date}`,
  STATS_USER: (userId: string) => `stats:user:${userId}`
}

// 缓存管理器
class CacheManager {
  private redis: Redis

  constructor(redisClient: Redis) {
    this.redis = redisClient
  }

  // 用户会话管理
  async setUserSession(userId: string, sessionData: any, ttl: number = 86400) {
    await this.redis.setex(
      RedisKeys.USER_SESSION(userId),
      ttl,
      JSON.stringify(sessionData)
    )
  }

  async getUserSession(userId: string): Promise<any | null> {
    const data = await this.redis.get(RedisKeys.USER_SESSION(userId))
    return data ? JSON.parse(data) : null
  }

  // 在线用户管理
  async setUserOnline(userId: string, socketId: string) {
    await this.redis.setex(RedisKeys.USER_ONLINE(userId), 300, socketId) // 5分钟过期
  }

  async isUserOnline(userId: string): Promise<boolean> {
    const exists = await this.redis.exists(RedisKeys.USER_ONLINE(userId))
    return exists === 1
  }

  // 匹配队列管理
  async addToMatchingQueue(userId: string, grade: string, criteria: any) {
    const queueData = {
      userId,
      criteria,
      joinTime: Date.now()
    }

    await this.redis.zadd(
      RedisKeys.MATCHING_QUEUE(grade),
      Date.now(),
      JSON.stringify(queueData)
    )

    await this.redis.setex(
      RedisKeys.MATCHING_USER(userId),
      300, // 5分钟超时
      grade
    )
  }

  async removeFromMatchingQueue(userId: string) {
    const grade = await this.redis.get(RedisKeys.MATCHING_USER(userId))
    if (grade) {
      // 从队列中移除用户
      const queueMembers = await this.redis.zrange(RedisKeys.MATCHING_QUEUE(grade), 0, -1)
      for (const member of queueMembers) {
        const data = JSON.parse(member)
        if (data.userId === userId) {
          await this.redis.zrem(RedisKeys.MATCHING_QUEUE(grade), member)
          break
        }
      }

      await this.redis.del(RedisKeys.MATCHING_USER(userId))
    }
  }

  // 游戏房间管理
  async setGameRoom(roomId: string, roomData: any, ttl: number = 3600) {
    await this.redis.setex(
      RedisKeys.GAME_ROOM(roomId),
      ttl,
      JSON.stringify(roomData)
    )
  }

  async getGameRoom(roomId: string): Promise<any | null> {
    const data = await this.redis.get(RedisKeys.GAME_ROOM(roomId))
    return data ? JSON.parse(data) : null
  }

  // 排行榜缓存
  async updateLeaderboard(type: 'weekly' | 'monthly' | 'all_time', data: any[]) {
    const key = type === 'weekly' ? RedisKeys.LEADERBOARD_WEEKLY :
                type === 'monthly' ? RedisKeys.LEADERBOARD_MONTHLY :
                RedisKeys.LEADERBOARD_ALL_TIME

    await this.redis.setex(key, 3600, JSON.stringify(data)) // 1小时缓存
  }

  async getLeaderboard(type: 'weekly' | 'monthly' | 'all_time'): Promise<any[] | null> {
    const key = type === 'weekly' ? RedisKeys.LEADERBOARD_WEEKLY :
                type === 'monthly' ? RedisKeys.LEADERBOARD_MONTHLY :
                RedisKeys.LEADERBOARD_ALL_TIME

    const data = await this.redis.get(key)
    return data ? JSON.parse(data) : null
  }
}
```
