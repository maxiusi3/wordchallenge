# 双人对抗单词闯关游戏 - 技术文档 - 第1部分

## 📋 文档信息
- **版本**: v1.0
- **创建日期**: 2024年12月
- **技术负责人**: 开发团队
- **适用范围**: 从单人游戏升级到双人对抗游戏

## 🏗️ 系统架构设计

### 整体架构
```
┌─────────────────────────────────────────────────────────┐
│                    客户端层 (Frontend)                   │
├─────────────────────────────────────────────────────────┤
│  Web App (React/Vue) │ 微信小程序 │ 原生App (可选)      │
└─────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────┐
│                    网关层 (Gateway)                      │
├─────────────────────────────────────────────────────────┤
│  Nginx/CDN │ 负载均衡 │ SSL终止 │ 静态资源服务          │
└─────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────┐
│                   应用服务层 (Backend)                   │
├─────────────────────────────────────────────────────────┤
│  用户服务 │ 匹配服务 │ 游戏服务 │ 实时通信服务          │
│  认证服务 │ 好友服务 │ 排行榜服务 │ 数据统计服务        │
└─────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────┐
│                    数据层 (Database)                     │
├─────────────────────────────────────────────────────────┤
│  MySQL/PostgreSQL │ Redis │ MongoDB │ 文件存储          │
│  用户数据 │ 缓存 │ 游戏记录 │ 静态资源                  │
└─────────────────────────────────────────────────────────┘
```

### 技术栈选择

#### 前端技术栈
```javascript
// 主要技术栈
{
  "framework": "Vue.js 3.x / React 18.x",
  "ui": "Tailwind CSS + 自定义组件",
  "state": "Vuex/Pinia 或 Redux Toolkit",
  "router": "Vue Router 或 React Router",
  "websocket": "Socket.io-client",
  "animation": "CSS3 + Lottie + Canvas",
  "build": "Vite 或 Webpack 5",
  "testing": "Jest + Vue Test Utils / React Testing Library"
}
```

#### 后端技术栈
```javascript
// 主要技术栈
{
  "runtime": "Node.js 18+ / Python 3.9+ / Go 1.19+",
  "framework": "Express.js / FastAPI / Gin",
  "websocket": "Socket.io / WebSocket原生",
  "database": "PostgreSQL + Redis + MongoDB",
  "auth": "JWT + OAuth 2.0",
  "cache": "Redis + 内存缓存",
  "queue": "Redis Queue / RabbitMQ",
  "monitoring": "Prometheus + Grafana",
  "logging": "Winston / Loguru / Zap"
}
```

## 🔧 核心模块设计

### 1. 用户认证模块 (Auth Module)

#### 架构设计
```typescript
// 用户认证服务接口
interface AuthService {
  // 第三方登录
  loginWithWechat(code: string): Promise<AuthResult>
  loginWithQQ(code: string): Promise<AuthResult>
  
  // 游客登录
  loginAsGuest(nickname: string, grade: string): Promise<AuthResult>
  
  // Token管理
  refreshToken(refreshToken: string): Promise<TokenPair>
  validateToken(token: string): Promise<UserInfo>
  
  // 账号绑定
  bindAccount(userId: string, provider: string, code: string): Promise<boolean>
}

// 数据结构
interface UserInfo {
  id: string
  nickname: string
  avatar: string
  grade: string
  level: number
  exp: number
  coins: number
  winRate: number
  totalGames: number
  createdAt: Date
  lastLoginAt: Date
}

interface AuthResult {
  user: UserInfo
  accessToken: string
  refreshToken: string
  expiresIn: number
}
```

#### 实现细节
```typescript
// JWT Token结构
interface JWTPayload {
  userId: string
  nickname: string
  grade: string
  iat: number
  exp: number
}

// 第三方登录配置
const OAuthConfig = {
  wechat: {
    appId: process.env.WECHAT_APP_ID,
    appSecret: process.env.WECHAT_APP_SECRET,
    redirectUri: process.env.WECHAT_REDIRECT_URI
  },
  qq: {
    appId: process.env.QQ_APP_ID,
    appKey: process.env.QQ_APP_KEY,
    redirectUri: process.env.QQ_REDIRECT_URI
  }
}

// 用户数据库模型
const UserSchema = {
  id: { type: 'uuid', primary: true },
  nickname: { type: 'varchar', length: 50, unique: true },
  avatar: { type: 'varchar', length: 255 },
  grade: { type: 'varchar', length: 20 },
  level: { type: 'integer', default: 1 },
  exp: { type: 'integer', default: 0 },
  coins: { type: 'integer', default: 100 },
  winRate: { type: 'decimal', precision: 5, scale: 2, default: 0 },
  totalGames: { type: 'integer', default: 0 },
  wechatOpenId: { type: 'varchar', length: 100, nullable: true },
  qqOpenId: { type: 'varchar', length: 100, nullable: true },
  isGuest: { type: 'boolean', default: false },
  createdAt: { type: 'timestamp', default: 'now()' },
  updatedAt: { type: 'timestamp', default: 'now()' },
  lastLoginAt: { type: 'timestamp', nullable: true }
}
```

### 2. 实时通信模块 (WebSocket Module)

#### 架构设计
```typescript
// WebSocket事件定义
enum SocketEvents {
  // 连接管理
  CONNECT = 'connect',
  DISCONNECT = 'disconnect',
  
  // 匹配相关
  JOIN_MATCHING = 'join_matching',
  LEAVE_MATCHING = 'leave_matching',
  MATCH_FOUND = 'match_found',
  MATCH_CANCELLED = 'match_cancelled',
  
  // 游戏房间
  JOIN_ROOM = 'join_room',
  LEAVE_ROOM = 'leave_room',
  ROOM_STATE_UPDATE = 'room_state_update',
  
  // 游戏进行
  GAME_START = 'game_start',
  PLAYER_ANSWER = 'player_answer',
  ANSWER_RESULT = 'answer_result',
  GAME_STATE_UPDATE = 'game_state_update',
  LEVEL_COMPLETE = 'level_complete',
  GAME_END = 'game_end',
  
  // 好友功能
  FRIEND_INVITE = 'friend_invite',
  FRIEND_ONLINE = 'friend_online',
  FRIEND_OFFLINE = 'friend_offline'
}

// 房间状态管理
interface GameRoom {
  id: string
  players: Player[]
  state: RoomState
  currentLevel: number
  currentQuestion: Question
  gameConfig: GameConfig
  minigame: MinigameState
  createdAt: Date
  startedAt?: Date
}

interface Player {
  userId: string
  nickname: string
  avatar: string
  grade: string
  isReady: boolean
  score: number[]  // 每关得分
  totalScore: number
  answers: Answer[]
  isOnline: boolean
}

enum RoomState {
  WAITING = 'waiting',
  READY = 'ready',
  PLAYING = 'playing',
  PAUSED = 'paused',
  FINISHED = 'finished'
}
```

#### WebSocket服务实现
```typescript
// Socket.io服务器配置
import { Server } from 'socket.io'
import { createAdapter } from '@socket.io/redis-adapter'
import { createClient } from 'redis'

class GameSocketServer {
  private io: Server
  private redisClient: any
  private rooms: Map<string, GameRoom> = new Map()
  private userSockets: Map<string, string> = new Map() // userId -> socketId
  
  constructor(httpServer: any) {
    this.io = new Server(httpServer, {
      cors: {
        origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
        methods: ['GET', 'POST']
      },
      transports: ['websocket', 'polling']
    })
    
    this.setupRedisAdapter()
    this.setupEventHandlers()
  }
  
  private setupRedisAdapter() {
    const pubClient = createClient({ url: process.env.REDIS_URL })
    const subClient = pubClient.duplicate()
    
    this.io.adapter(createAdapter(pubClient, subClient))
    this.redisClient = pubClient
  }
  
  private setupEventHandlers() {
    this.io.on('connection', (socket) => {
      console.log(`用户连接: ${socket.id}`)
      
      // 用户认证
      socket.on('authenticate', async (token: string) => {
        try {
          const user = await this.validateToken(token)
          socket.userId = user.id
          socket.userInfo = user
          this.userSockets.set(user.id, socket.id)
          
          // 通知好友上线
          this.notifyFriendsOnline(user.id)
          
          socket.emit('authenticated', { success: true, user })
        } catch (error) {
          socket.emit('auth_error', { message: '认证失败' })
          socket.disconnect()
        }
      })
      
      // 加入匹配队列
      socket.on(SocketEvents.JOIN_MATCHING, (data) => {
        this.handleJoinMatching(socket, data)
      })
      
      // 离开匹配队列
      socket.on(SocketEvents.LEAVE_MATCHING, () => {
        this.handleLeaveMatching(socket)
      })
      
      // 玩家答题
      socket.on(SocketEvents.PLAYER_ANSWER, (data) => {
        this.handlePlayerAnswer(socket, data)
      })
      
      // 断开连接
      socket.on('disconnect', () => {
        this.handleDisconnect(socket)
      })
    })
  }
  
  private async handleJoinMatching(socket: any, data: any) {
    const { grade, mode } = data
    const userId = socket.userId
    
    // 添加到匹配队列
    await this.addToMatchingQueue(userId, grade, mode)
    
    // 尝试匹配
    const match = await this.findMatch(userId, grade, mode)
    
    if (match) {
      // 创建游戏房间
      const room = await this.createGameRoom(match.players)
      
      // 通知匹配成功
      match.players.forEach(playerId => {
        const playerSocket = this.io.sockets.sockets.get(this.userSockets.get(playerId))
        if (playerSocket) {
          playerSocket.join(room.id)
          playerSocket.emit(SocketEvents.MATCH_FOUND, {
            roomId: room.id,
            opponent: room.players.find(p => p.userId !== playerId),
            gameConfig: room.gameConfig
          })
        }
      })
    } else {
      socket.emit('matching_status', { status: 'waiting', estimatedTime: 30 })
    }
  }
}
```

### 3. 匹配系统模块 (Matching Module)

#### 匹配算法设计
```typescript
// 匹配服务接口
interface MatchingService {
  addToQueue(userId: string, criteria: MatchCriteria): Promise<void>
  removeFromQueue(userId: string): Promise<void>
  findMatch(userId: string): Promise<MatchResult | null>
  getQueueStatus(userId: string): Promise<QueueStatus>
}

// 匹配条件
interface MatchCriteria {
  grade: string
  level: number
  winRate: number
  mode: 'quick' | 'ranked' | 'friend'
  preferredOpponent?: string // 好友对战时指定对手
}

// 匹配结果
interface MatchResult {
  players: string[]
  roomId: string
  gameConfig: GameConfig
  estimatedStartTime: Date
}

// 队列状态
interface QueueStatus {
  position: number
  estimatedWaitTime: number
  playersInQueue: number
}
```

#### 匹配算法实现
```typescript
class SmartMatchingAlgorithm {
  private queue: Map<string, QueueEntry> = new Map()
  private gradeWeights = {
    'grade3': 1, 'grade4': 2, 'grade5': 3, 'grade6': 4,
    'grade7': 5, 'grade8': 6, 'grade9': 7,
    'grade10': 8, 'grade11': 9, 'grade12': 10
  }
  
  async findBestMatch(userId: string): Promise<MatchResult | null> {
    const userEntry = this.queue.get(userId)
    if (!userEntry) return null
    
    const candidates = Array.from(this.queue.values())
      .filter(entry => entry.userId !== userId)
      .filter(entry => this.isValidMatch(userEntry, entry))
      .sort((a, b) => this.calculateMatchScore(userEntry, b) - this.calculateMatchScore(userEntry, a))
    
    if (candidates.length === 0) return null
    
    const bestMatch = candidates[0]
    
    // 从队列中移除匹配的玩家
    this.queue.delete(userId)
    this.queue.delete(bestMatch.userId)
    
    // 创建游戏配置
    const gameConfig = this.generateGameConfig(userEntry, bestMatch)
    
    return {
      players: [userId, bestMatch.userId],
      roomId: this.generateRoomId(),
      gameConfig,
      estimatedStartTime: new Date(Date.now() + 5000) // 5秒准备时间
    }
  }
  
  private isValidMatch(user1: QueueEntry, user2: QueueEntry): boolean {
    // 年级差距不超过2级
    const gradeDiff = Math.abs(
      this.gradeWeights[user1.criteria.grade] - this.gradeWeights[user2.criteria.grade]
    )
    if (gradeDiff > 2) return false
    
    // 等级差距不超过5级
    const levelDiff = Math.abs(user1.criteria.level - user2.criteria.level)
    if (levelDiff > 5) return false
    
    // 胜率差距不超过30%
    const winRateDiff = Math.abs(user1.criteria.winRate - user2.criteria.winRate)
    if (winRateDiff > 0.3) return false
    
    return true
  }
  
  private calculateMatchScore(user1: QueueEntry, user2: QueueEntry): number {
    // 计算匹配度分数，分数越高匹配度越好
    let score = 100
    
    // 年级匹配度 (权重: 40%)
    const gradeDiff = Math.abs(
      this.gradeWeights[user1.criteria.grade] - this.gradeWeights[user2.criteria.grade]
    )
    score -= gradeDiff * 10
    
    // 等级匹配度 (权重: 30%)
    const levelDiff = Math.abs(user1.criteria.level - user2.criteria.level)
    score -= levelDiff * 2
    
    // 胜率匹配度 (权重: 20%)
    const winRateDiff = Math.abs(user1.criteria.winRate - user2.criteria.winRate)
    score -= winRateDiff * 50
    
    // 等待时间奖励 (权重: 10%)
    const waitTime = Date.now() - user2.joinTime
    score += Math.min(waitTime / 1000 / 60, 10) // 每分钟+1分，最多+10分
    
    return Math.max(score, 0)
  }
  
  private generateGameConfig(user1: QueueEntry, user2: QueueEntry): GameConfig {
    // 根据双方水平生成游戏配置
    const avgLevel = (user1.criteria.level + user2.criteria.level) / 2
    const avgWinRate = (user1.criteria.winRate + user2.criteria.winRate) / 2
    
    return {
      questionsPerLevel: this.getQuestionsPerLevel(avgLevel),
      timeLimit: this.getTimeLimit(avgLevel),
      difficulty: this.getDifficulty(avgWinRate),
      minigames: this.selectMinigames(),
      grade: this.selectGrade(user1.criteria.grade, user2.criteria.grade)
    }
  }
}
```

### 4. 游戏逻辑模块 (Game Logic Module)

#### 游戏状态管理
```typescript
// 游戏状态管理器
class GameStateManager {
  private rooms: Map<string, GameRoom> = new Map()
  private questionPool: Map<string, Question[]> = new Map()
  private minigameEngine: MinigameEngine
  
  constructor() {
    this.minigameEngine = new MinigameEngine()
    this.loadQuestionPools()
  }
  
  async startGame(roomId: string): Promise<void> {
    const room = this.rooms.get(roomId)
    if (!room) throw new Error('房间不存在')
    
    // 初始化游戏状态
    room.state = RoomState.PLAYING
    room.currentLevel = 1
    room.startedAt = new Date()
    
    // 选择小游戏
    room.minigame = this.minigameEngine.initializeMinigame(
      room.gameConfig.minigames[0],
      room.players.length
    )
    
    // 加载第一题
    await this.loadNextQuestion(roomId)
    
    // 通知客户端游戏开始
    this.broadcastToRoom(roomId, SocketEvents.GAME_START, {
      level: room.currentLevel,
      minigame: room.minigame,
      question: room.currentQuestion
    })
  }
  
  async handlePlayerAnswer(roomId: string, userId: string, answer: string): Promise<void> {
    const room = this.rooms.get(roomId)
    if (!room || room.state !== RoomState.PLAYING) return
    
    const player = room.players.find(p => p.userId === userId)
    if (!player) return
    
    // 检查答案
    const isCorrect = this.checkAnswer(room.currentQuestion, answer)
    const responseTime = Date.now() - room.currentQuestion.startTime
    
    // 记录答案
    player.answers.push({
      questionId: room.currentQuestion.id,
      answer,
      isCorrect,
      responseTime,
      timestamp: new Date()
    })
    
    // 更新小游戏状态
    this.minigameEngine.updateGameState(room.minigame, userId, isCorrect)
    
    // 更新玩家分数
    if (isCorrect) {
      player.score[room.currentLevel - 1]++
      player.totalScore++
    }
    
    // 广播答题结果
    this.broadcastToRoom(roomId, SocketEvents.ANSWER_RESULT, {
      userId,
      isCorrect,
      responseTime,
      minigameState: room.minigame,
      scores: room.players.map(p => ({ userId: p.userId, score: p.totalScore }))
    })
    
    // 检查是否需要进入下一题或下一关
    await this.checkGameProgress(roomId)
  }
  
  private async checkGameProgress(roomId: string): Promise<void> {
    const room = this.rooms.get(roomId)
    if (!room) return
    
    const config = room.gameConfig
    const currentLevelQuestions = player.answers.filter(a => 
      a.questionId.startsWith(`level${room.currentLevel}`)
    ).length
    
    // 检查当前关卡是否完成
    if (currentLevelQuestions >= config.questionsPerLevel) {
      await this.completeLevel(roomId)
    } else {
      // 加载下一题
      await this.loadNextQuestion(roomId)
    }
  }
  
  private async completeLevel(roomId: string): Promise<void> {
    const room = this.rooms.get(roomId)
    if (!room) return
    
    // 计算关卡结果
    const levelResults = this.calculateLevelResults(room)
    
    // 广播关卡完成
    this.broadcastToRoom(roomId, SocketEvents.LEVEL_COMPLETE, {
      level: room.currentLevel,
      results: levelResults,
      minigameFinalState: room.minigame
    })
    
    // 检查是否游戏结束
    if (room.currentLevel >= 3) {
      await this.endGame(roomId)
    } else {
      // 进入下一关
      room.currentLevel++
      room.minigame = this.minigameEngine.initializeMinigame(
        room.gameConfig.minigames[room.currentLevel - 1],
        room.players.length
      )
      
      setTimeout(() => {
        this.loadNextQuestion(roomId)
      }, 3000) // 3秒间隔
    }
  }
}
```
