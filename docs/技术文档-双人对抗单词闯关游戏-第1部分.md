# åŒäººå¯¹æŠ—å•è¯é—¯å…³æ¸¸æˆ - æŠ€æœ¯æ–‡æ¡£ - ç¬¬1éƒ¨åˆ†

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯
- **ç‰ˆæœ¬**: v1.0
- **åˆ›å»ºæ—¥æœŸ**: 2024å¹´12æœˆ
- **æŠ€æœ¯è´Ÿè´£äºº**: å¼€å‘å›¢é˜Ÿ
- **é€‚ç”¨èŒƒå›´**: ä»å•äººæ¸¸æˆå‡çº§åˆ°åŒäººå¯¹æŠ—æ¸¸æˆ

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å®¢æˆ·ç«¯å±‚ (Frontend)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Web App (React/Vue) â”‚ å¾®ä¿¡å°ç¨‹åº â”‚ åŸç”ŸApp (å¯é€‰)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ç½‘å…³å±‚ (Gateway)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Nginx/CDN â”‚ è´Ÿè½½å‡è¡¡ â”‚ SSLç»ˆæ­¢ â”‚ é™æ€èµ„æºæœåŠ¡          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   åº”ç”¨æœåŠ¡å±‚ (Backend)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ç”¨æˆ·æœåŠ¡ â”‚ åŒ¹é…æœåŠ¡ â”‚ æ¸¸æˆæœåŠ¡ â”‚ å®æ—¶é€šä¿¡æœåŠ¡          â”‚
â”‚  è®¤è¯æœåŠ¡ â”‚ å¥½å‹æœåŠ¡ â”‚ æ’è¡Œæ¦œæœåŠ¡ â”‚ æ•°æ®ç»Ÿè®¡æœåŠ¡        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ•°æ®å±‚ (Database)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  MySQL/PostgreSQL â”‚ Redis â”‚ MongoDB â”‚ æ–‡ä»¶å­˜å‚¨          â”‚
â”‚  ç”¨æˆ·æ•°æ® â”‚ ç¼“å­˜ â”‚ æ¸¸æˆè®°å½• â”‚ é™æ€èµ„æº                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æŠ€æœ¯æ ˆé€‰æ‹©

#### å‰ç«¯æŠ€æœ¯æ ˆ
```javascript
// ä¸»è¦æŠ€æœ¯æ ˆ
{
  "framework": "Vue.js 3.x / React 18.x",
  "ui": "Tailwind CSS + è‡ªå®šä¹‰ç»„ä»¶",
  "state": "Vuex/Pinia æˆ– Redux Toolkit",
  "router": "Vue Router æˆ– React Router",
  "websocket": "Socket.io-client",
  "animation": "CSS3 + Lottie + Canvas",
  "build": "Vite æˆ– Webpack 5",
  "testing": "Jest + Vue Test Utils / React Testing Library"
}
```

#### åç«¯æŠ€æœ¯æ ˆ
```javascript
// ä¸»è¦æŠ€æœ¯æ ˆ
{
  "runtime": "Node.js 18+ / Python 3.9+ / Go 1.19+",
  "framework": "Express.js / FastAPI / Gin",
  "websocket": "Socket.io / WebSocketåŸç”Ÿ",
  "database": "PostgreSQL + Redis + MongoDB",
  "auth": "JWT + OAuth 2.0",
  "cache": "Redis + å†…å­˜ç¼“å­˜",
  "queue": "Redis Queue / RabbitMQ",
  "monitoring": "Prometheus + Grafana",
  "logging": "Winston / Loguru / Zap"
}
```

## ğŸ”§ æ ¸å¿ƒæ¨¡å—è®¾è®¡

### 1. ç”¨æˆ·è®¤è¯æ¨¡å— (Auth Module)

#### æ¶æ„è®¾è®¡
```typescript
// ç”¨æˆ·è®¤è¯æœåŠ¡æ¥å£
interface AuthService {
  // ç¬¬ä¸‰æ–¹ç™»å½•
  loginWithWechat(code: string): Promise<AuthResult>
  loginWithQQ(code: string): Promise<AuthResult>
  
  // æ¸¸å®¢ç™»å½•
  loginAsGuest(nickname: string, grade: string): Promise<AuthResult>
  
  // Tokenç®¡ç†
  refreshToken(refreshToken: string): Promise<TokenPair>
  validateToken(token: string): Promise<UserInfo>
  
  // è´¦å·ç»‘å®š
  bindAccount(userId: string, provider: string, code: string): Promise<boolean>
}

// æ•°æ®ç»“æ„
interface UserInfo {
  id: string
  nickname: string
  avatar: string
  grade: string
  level: number
  exp: number
  coins: number
  winRate: number
  totalGames: number
  createdAt: Date
  lastLoginAt: Date
}

interface AuthResult {
  user: UserInfo
  accessToken: string
  refreshToken: string
  expiresIn: number
}
```

#### å®ç°ç»†èŠ‚
```typescript
// JWT Tokenç»“æ„
interface JWTPayload {
  userId: string
  nickname: string
  grade: string
  iat: number
  exp: number
}

// ç¬¬ä¸‰æ–¹ç™»å½•é…ç½®
const OAuthConfig = {
  wechat: {
    appId: process.env.WECHAT_APP_ID,
    appSecret: process.env.WECHAT_APP_SECRET,
    redirectUri: process.env.WECHAT_REDIRECT_URI
  },
  qq: {
    appId: process.env.QQ_APP_ID,
    appKey: process.env.QQ_APP_KEY,
    redirectUri: process.env.QQ_REDIRECT_URI
  }
}

// ç”¨æˆ·æ•°æ®åº“æ¨¡å‹
const UserSchema = {
  id: { type: 'uuid', primary: true },
  nickname: { type: 'varchar', length: 50, unique: true },
  avatar: { type: 'varchar', length: 255 },
  grade: { type: 'varchar', length: 20 },
  level: { type: 'integer', default: 1 },
  exp: { type: 'integer', default: 0 },
  coins: { type: 'integer', default: 100 },
  winRate: { type: 'decimal', precision: 5, scale: 2, default: 0 },
  totalGames: { type: 'integer', default: 0 },
  wechatOpenId: { type: 'varchar', length: 100, nullable: true },
  qqOpenId: { type: 'varchar', length: 100, nullable: true },
  isGuest: { type: 'boolean', default: false },
  createdAt: { type: 'timestamp', default: 'now()' },
  updatedAt: { type: 'timestamp', default: 'now()' },
  lastLoginAt: { type: 'timestamp', nullable: true }
}
```

### 2. å®æ—¶é€šä¿¡æ¨¡å— (WebSocket Module)

#### æ¶æ„è®¾è®¡
```typescript
// WebSocketäº‹ä»¶å®šä¹‰
enum SocketEvents {
  // è¿æ¥ç®¡ç†
  CONNECT = 'connect',
  DISCONNECT = 'disconnect',
  
  // åŒ¹é…ç›¸å…³
  JOIN_MATCHING = 'join_matching',
  LEAVE_MATCHING = 'leave_matching',
  MATCH_FOUND = 'match_found',
  MATCH_CANCELLED = 'match_cancelled',
  
  // æ¸¸æˆæˆ¿é—´
  JOIN_ROOM = 'join_room',
  LEAVE_ROOM = 'leave_room',
  ROOM_STATE_UPDATE = 'room_state_update',
  
  // æ¸¸æˆè¿›è¡Œ
  GAME_START = 'game_start',
  PLAYER_ANSWER = 'player_answer',
  ANSWER_RESULT = 'answer_result',
  GAME_STATE_UPDATE = 'game_state_update',
  LEVEL_COMPLETE = 'level_complete',
  GAME_END = 'game_end',
  
  // å¥½å‹åŠŸèƒ½
  FRIEND_INVITE = 'friend_invite',
  FRIEND_ONLINE = 'friend_online',
  FRIEND_OFFLINE = 'friend_offline'
}

// æˆ¿é—´çŠ¶æ€ç®¡ç†
interface GameRoom {
  id: string
  players: Player[]
  state: RoomState
  currentLevel: number
  currentQuestion: Question
  gameConfig: GameConfig
  minigame: MinigameState
  createdAt: Date
  startedAt?: Date
}

interface Player {
  userId: string
  nickname: string
  avatar: string
  grade: string
  isReady: boolean
  score: number[]  // æ¯å…³å¾—åˆ†
  totalScore: number
  answers: Answer[]
  isOnline: boolean
}

enum RoomState {
  WAITING = 'waiting',
  READY = 'ready',
  PLAYING = 'playing',
  PAUSED = 'paused',
  FINISHED = 'finished'
}
```

#### WebSocketæœåŠ¡å®ç°
```typescript
// Socket.ioæœåŠ¡å™¨é…ç½®
import { Server } from 'socket.io'
import { createAdapter } from '@socket.io/redis-adapter'
import { createClient } from 'redis'

class GameSocketServer {
  private io: Server
  private redisClient: any
  private rooms: Map<string, GameRoom> = new Map()
  private userSockets: Map<string, string> = new Map() // userId -> socketId
  
  constructor(httpServer: any) {
    this.io = new Server(httpServer, {
      cors: {
        origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
        methods: ['GET', 'POST']
      },
      transports: ['websocket', 'polling']
    })
    
    this.setupRedisAdapter()
    this.setupEventHandlers()
  }
  
  private setupRedisAdapter() {
    const pubClient = createClient({ url: process.env.REDIS_URL })
    const subClient = pubClient.duplicate()
    
    this.io.adapter(createAdapter(pubClient, subClient))
    this.redisClient = pubClient
  }
  
  private setupEventHandlers() {
    this.io.on('connection', (socket) => {
      console.log(`ç”¨æˆ·è¿æ¥: ${socket.id}`)
      
      // ç”¨æˆ·è®¤è¯
      socket.on('authenticate', async (token: string) => {
        try {
          const user = await this.validateToken(token)
          socket.userId = user.id
          socket.userInfo = user
          this.userSockets.set(user.id, socket.id)
          
          // é€šçŸ¥å¥½å‹ä¸Šçº¿
          this.notifyFriendsOnline(user.id)
          
          socket.emit('authenticated', { success: true, user })
        } catch (error) {
          socket.emit('auth_error', { message: 'è®¤è¯å¤±è´¥' })
          socket.disconnect()
        }
      })
      
      // åŠ å…¥åŒ¹é…é˜Ÿåˆ—
      socket.on(SocketEvents.JOIN_MATCHING, (data) => {
        this.handleJoinMatching(socket, data)
      })
      
      // ç¦»å¼€åŒ¹é…é˜Ÿåˆ—
      socket.on(SocketEvents.LEAVE_MATCHING, () => {
        this.handleLeaveMatching(socket)
      })
      
      // ç©å®¶ç­”é¢˜
      socket.on(SocketEvents.PLAYER_ANSWER, (data) => {
        this.handlePlayerAnswer(socket, data)
      })
      
      // æ–­å¼€è¿æ¥
      socket.on('disconnect', () => {
        this.handleDisconnect(socket)
      })
    })
  }
  
  private async handleJoinMatching(socket: any, data: any) {
    const { grade, mode } = data
    const userId = socket.userId
    
    // æ·»åŠ åˆ°åŒ¹é…é˜Ÿåˆ—
    await this.addToMatchingQueue(userId, grade, mode)
    
    // å°è¯•åŒ¹é…
    const match = await this.findMatch(userId, grade, mode)
    
    if (match) {
      // åˆ›å»ºæ¸¸æˆæˆ¿é—´
      const room = await this.createGameRoom(match.players)
      
      // é€šçŸ¥åŒ¹é…æˆåŠŸ
      match.players.forEach(playerId => {
        const playerSocket = this.io.sockets.sockets.get(this.userSockets.get(playerId))
        if (playerSocket) {
          playerSocket.join(room.id)
          playerSocket.emit(SocketEvents.MATCH_FOUND, {
            roomId: room.id,
            opponent: room.players.find(p => p.userId !== playerId),
            gameConfig: room.gameConfig
          })
        }
      })
    } else {
      socket.emit('matching_status', { status: 'waiting', estimatedTime: 30 })
    }
  }
}
```

### 3. åŒ¹é…ç³»ç»Ÿæ¨¡å— (Matching Module)

#### åŒ¹é…ç®—æ³•è®¾è®¡
```typescript
// åŒ¹é…æœåŠ¡æ¥å£
interface MatchingService {
  addToQueue(userId: string, criteria: MatchCriteria): Promise<void>
  removeFromQueue(userId: string): Promise<void>
  findMatch(userId: string): Promise<MatchResult | null>
  getQueueStatus(userId: string): Promise<QueueStatus>
}

// åŒ¹é…æ¡ä»¶
interface MatchCriteria {
  grade: string
  level: number
  winRate: number
  mode: 'quick' | 'ranked' | 'friend'
  preferredOpponent?: string // å¥½å‹å¯¹æˆ˜æ—¶æŒ‡å®šå¯¹æ‰‹
}

// åŒ¹é…ç»“æœ
interface MatchResult {
  players: string[]
  roomId: string
  gameConfig: GameConfig
  estimatedStartTime: Date
}

// é˜Ÿåˆ—çŠ¶æ€
interface QueueStatus {
  position: number
  estimatedWaitTime: number
  playersInQueue: number
}
```

#### åŒ¹é…ç®—æ³•å®ç°
```typescript
class SmartMatchingAlgorithm {
  private queue: Map<string, QueueEntry> = new Map()
  private gradeWeights = {
    'grade3': 1, 'grade4': 2, 'grade5': 3, 'grade6': 4,
    'grade7': 5, 'grade8': 6, 'grade9': 7,
    'grade10': 8, 'grade11': 9, 'grade12': 10
  }
  
  async findBestMatch(userId: string): Promise<MatchResult | null> {
    const userEntry = this.queue.get(userId)
    if (!userEntry) return null
    
    const candidates = Array.from(this.queue.values())
      .filter(entry => entry.userId !== userId)
      .filter(entry => this.isValidMatch(userEntry, entry))
      .sort((a, b) => this.calculateMatchScore(userEntry, b) - this.calculateMatchScore(userEntry, a))
    
    if (candidates.length === 0) return null
    
    const bestMatch = candidates[0]
    
    // ä»é˜Ÿåˆ—ä¸­ç§»é™¤åŒ¹é…çš„ç©å®¶
    this.queue.delete(userId)
    this.queue.delete(bestMatch.userId)
    
    // åˆ›å»ºæ¸¸æˆé…ç½®
    const gameConfig = this.generateGameConfig(userEntry, bestMatch)
    
    return {
      players: [userId, bestMatch.userId],
      roomId: this.generateRoomId(),
      gameConfig,
      estimatedStartTime: new Date(Date.now() + 5000) // 5ç§’å‡†å¤‡æ—¶é—´
    }
  }
  
  private isValidMatch(user1: QueueEntry, user2: QueueEntry): boolean {
    // å¹´çº§å·®è·ä¸è¶…è¿‡2çº§
    const gradeDiff = Math.abs(
      this.gradeWeights[user1.criteria.grade] - this.gradeWeights[user2.criteria.grade]
    )
    if (gradeDiff > 2) return false
    
    // ç­‰çº§å·®è·ä¸è¶…è¿‡5çº§
    const levelDiff = Math.abs(user1.criteria.level - user2.criteria.level)
    if (levelDiff > 5) return false
    
    // èƒœç‡å·®è·ä¸è¶…è¿‡30%
    const winRateDiff = Math.abs(user1.criteria.winRate - user2.criteria.winRate)
    if (winRateDiff > 0.3) return false
    
    return true
  }
  
  private calculateMatchScore(user1: QueueEntry, user2: QueueEntry): number {
    // è®¡ç®—åŒ¹é…åº¦åˆ†æ•°ï¼Œåˆ†æ•°è¶Šé«˜åŒ¹é…åº¦è¶Šå¥½
    let score = 100
    
    // å¹´çº§åŒ¹é…åº¦ (æƒé‡: 40%)
    const gradeDiff = Math.abs(
      this.gradeWeights[user1.criteria.grade] - this.gradeWeights[user2.criteria.grade]
    )
    score -= gradeDiff * 10
    
    // ç­‰çº§åŒ¹é…åº¦ (æƒé‡: 30%)
    const levelDiff = Math.abs(user1.criteria.level - user2.criteria.level)
    score -= levelDiff * 2
    
    // èƒœç‡åŒ¹é…åº¦ (æƒé‡: 20%)
    const winRateDiff = Math.abs(user1.criteria.winRate - user2.criteria.winRate)
    score -= winRateDiff * 50
    
    // ç­‰å¾…æ—¶é—´å¥–åŠ± (æƒé‡: 10%)
    const waitTime = Date.now() - user2.joinTime
    score += Math.min(waitTime / 1000 / 60, 10) // æ¯åˆ†é’Ÿ+1åˆ†ï¼Œæœ€å¤š+10åˆ†
    
    return Math.max(score, 0)
  }
  
  private generateGameConfig(user1: QueueEntry, user2: QueueEntry): GameConfig {
    // æ ¹æ®åŒæ–¹æ°´å¹³ç”Ÿæˆæ¸¸æˆé…ç½®
    const avgLevel = (user1.criteria.level + user2.criteria.level) / 2
    const avgWinRate = (user1.criteria.winRate + user2.criteria.winRate) / 2
    
    return {
      questionsPerLevel: this.getQuestionsPerLevel(avgLevel),
      timeLimit: this.getTimeLimit(avgLevel),
      difficulty: this.getDifficulty(avgWinRate),
      minigames: this.selectMinigames(),
      grade: this.selectGrade(user1.criteria.grade, user2.criteria.grade)
    }
  }
}
```

### 4. æ¸¸æˆé€»è¾‘æ¨¡å— (Game Logic Module)

#### æ¸¸æˆçŠ¶æ€ç®¡ç†
```typescript
// æ¸¸æˆçŠ¶æ€ç®¡ç†å™¨
class GameStateManager {
  private rooms: Map<string, GameRoom> = new Map()
  private questionPool: Map<string, Question[]> = new Map()
  private minigameEngine: MinigameEngine
  
  constructor() {
    this.minigameEngine = new MinigameEngine()
    this.loadQuestionPools()
  }
  
  async startGame(roomId: string): Promise<void> {
    const room = this.rooms.get(roomId)
    if (!room) throw new Error('æˆ¿é—´ä¸å­˜åœ¨')
    
    // åˆå§‹åŒ–æ¸¸æˆçŠ¶æ€
    room.state = RoomState.PLAYING
    room.currentLevel = 1
    room.startedAt = new Date()
    
    // é€‰æ‹©å°æ¸¸æˆ
    room.minigame = this.minigameEngine.initializeMinigame(
      room.gameConfig.minigames[0],
      room.players.length
    )
    
    // åŠ è½½ç¬¬ä¸€é¢˜
    await this.loadNextQuestion(roomId)
    
    // é€šçŸ¥å®¢æˆ·ç«¯æ¸¸æˆå¼€å§‹
    this.broadcastToRoom(roomId, SocketEvents.GAME_START, {
      level: room.currentLevel,
      minigame: room.minigame,
      question: room.currentQuestion
    })
  }
  
  async handlePlayerAnswer(roomId: string, userId: string, answer: string): Promise<void> {
    const room = this.rooms.get(roomId)
    if (!room || room.state !== RoomState.PLAYING) return
    
    const player = room.players.find(p => p.userId === userId)
    if (!player) return
    
    // æ£€æŸ¥ç­”æ¡ˆ
    const isCorrect = this.checkAnswer(room.currentQuestion, answer)
    const responseTime = Date.now() - room.currentQuestion.startTime
    
    // è®°å½•ç­”æ¡ˆ
    player.answers.push({
      questionId: room.currentQuestion.id,
      answer,
      isCorrect,
      responseTime,
      timestamp: new Date()
    })
    
    // æ›´æ–°å°æ¸¸æˆçŠ¶æ€
    this.minigameEngine.updateGameState(room.minigame, userId, isCorrect)
    
    // æ›´æ–°ç©å®¶åˆ†æ•°
    if (isCorrect) {
      player.score[room.currentLevel - 1]++
      player.totalScore++
    }
    
    // å¹¿æ’­ç­”é¢˜ç»“æœ
    this.broadcastToRoom(roomId, SocketEvents.ANSWER_RESULT, {
      userId,
      isCorrect,
      responseTime,
      minigameState: room.minigame,
      scores: room.players.map(p => ({ userId: p.userId, score: p.totalScore }))
    })
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦è¿›å…¥ä¸‹ä¸€é¢˜æˆ–ä¸‹ä¸€å…³
    await this.checkGameProgress(roomId)
  }
  
  private async checkGameProgress(roomId: string): Promise<void> {
    const room = this.rooms.get(roomId)
    if (!room) return
    
    const config = room.gameConfig
    const currentLevelQuestions = player.answers.filter(a => 
      a.questionId.startsWith(`level${room.currentLevel}`)
    ).length
    
    // æ£€æŸ¥å½“å‰å…³å¡æ˜¯å¦å®Œæˆ
    if (currentLevelQuestions >= config.questionsPerLevel) {
      await this.completeLevel(roomId)
    } else {
      // åŠ è½½ä¸‹ä¸€é¢˜
      await this.loadNextQuestion(roomId)
    }
  }
  
  private async completeLevel(roomId: string): Promise<void> {
    const room = this.rooms.get(roomId)
    if (!room) return
    
    // è®¡ç®—å…³å¡ç»“æœ
    const levelResults = this.calculateLevelResults(room)
    
    // å¹¿æ’­å…³å¡å®Œæˆ
    this.broadcastToRoom(roomId, SocketEvents.LEVEL_COMPLETE, {
      level: room.currentLevel,
      results: levelResults,
      minigameFinalState: room.minigame
    })
    
    // æ£€æŸ¥æ˜¯å¦æ¸¸æˆç»“æŸ
    if (room.currentLevel >= 3) {
      await this.endGame(roomId)
    } else {
      // è¿›å…¥ä¸‹ä¸€å…³
      room.currentLevel++
      room.minigame = this.minigameEngine.initializeMinigame(
        room.gameConfig.minigames[room.currentLevel - 1],
        room.players.length
      )
      
      setTimeout(() => {
        this.loadNextQuestion(roomId)
      }, 3000) // 3ç§’é—´éš”
    }
  }
}
```
