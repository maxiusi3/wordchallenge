# 双人对抗单词闯关游戏 - 技术文档 - 第3部分

### 7. 前端架构设计

#### 状态管理架构
```typescript
// 使用Pinia/Vuex进行状态管理
interface AppState {
  user: UserState
  game: GameState
  socket: SocketState
  ui: UIState
}

interface UserState {
  isAuthenticated: boolean
  userInfo: UserInfo | null
  friends: Friend[]
  achievements: Achievement[]
  items: UserItem[]
}

interface GameState {
  currentRoom: GameRoom | null
  matchingStatus: MatchingStatus
  gameHistory: GameRecord[]
  leaderboard: LeaderboardEntry[]
}

interface SocketState {
  isConnected: boolean
  connectionStatus: 'connecting' | 'connected' | 'disconnected' | 'error'
  lastPing: number
  reconnectAttempts: number
}

interface UIState {
  currentScreen: string
  loading: boolean
  notifications: Notification[]
  modals: Modal[]
}
```

#### 组件架构设计
```vue
<!-- 主应用组件 -->
<template>
  <div id="app" class="min-h-screen bg-gradient-to-br from-blue-400 to-purple-600">
    <!-- 全局加载指示器 -->
    <LoadingOverlay v-if="loading" />
    
    <!-- 网络状态提示 -->
    <NetworkStatus />
    
    <!-- 主要内容区域 -->
    <router-view v-slot="{ Component }">
      <transition name="page" mode="out-in">
        <component :is="Component" />
      </transition>
    </router-view>
    
    <!-- 全局通知 -->
    <NotificationContainer />
    
    <!-- 模态框容器 -->
    <ModalContainer />
  </div>
</template>

<script setup lang="ts">
import { onMounted, computed } from 'vue'
import { useUserStore } from '@/stores/user'
import { useSocketStore } from '@/stores/socket'
import { useUIStore } from '@/stores/ui'

const userStore = useUserStore()
const socketStore = useSocketStore()
const uiStore = useUIStore()

const loading = computed(() => uiStore.loading)

onMounted(async () => {
  // 初始化应用
  await initializeApp()
})

async function initializeApp() {
  try {
    // 检查本地存储的用户信息
    await userStore.loadUserFromStorage()
    
    // 如果用户已登录，建立WebSocket连接
    if (userStore.isAuthenticated) {
      await socketStore.connect()
    }
    
    // 加载应用配置
    await loadAppConfig()
  } catch (error) {
    console.error('应用初始化失败:', error)
  }
}
</script>
```

#### 路由配置
```typescript
// router/index.ts
import { createRouter, createWebHistory } from 'vue-router'
import { useUserStore } from '@/stores/user'

const routes = [
  {
    path: '/',
    redirect: '/welcome'
  },
  {
    path: '/welcome',
    name: 'Welcome',
    component: () => import('@/views/Welcome.vue')
  },
  {
    path: '/login',
    name: 'Login',
    component: () => import('@/views/Login.vue')
  },
  {
    path: '/lobby',
    name: 'Lobby',
    component: () => import('@/views/Lobby.vue'),
    meta: { requiresAuth: true }
  },
  {
    path: '/matching',
    name: 'Matching',
    component: () => import('@/views/Matching.vue'),
    meta: { requiresAuth: true }
  },
  {
    path: '/battle/:roomId',
    name: 'Battle',
    component: () => import('@/views/Battle.vue'),
    meta: { requiresAuth: true }
  },
  {
    path: '/result',
    name: 'Result',
    component: () => import('@/views/Result.vue'),
    meta: { requiresAuth: true }
  },
  {
    path: '/friends',
    name: 'Friends',
    component: () => import('@/views/Friends.vue'),
    meta: { requiresAuth: true }
  },
  {
    path: '/leaderboard',
    name: 'Leaderboard',
    component: () => import('@/views/Leaderboard.vue'),
    meta: { requiresAuth: true }
  },
  {
    path: '/achievements',
    name: 'Achievements',
    component: () => import('@/views/Achievements.vue'),
    meta: { requiresAuth: true }
  },
  {
    path: '/shop',
    name: 'Shop',
    component: () => import('@/views/Shop.vue'),
    meta: { requiresAuth: true }
  },
  {
    path: '/settings',
    name: 'Settings',
    component: () => import('@/views/Settings.vue'),
    meta: { requiresAuth: true }
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

// 路由守卫
router.beforeEach((to, from, next) => {
  const userStore = useUserStore()
  
  if (to.meta.requiresAuth && !userStore.isAuthenticated) {
    next('/login')
  } else {
    next()
  }
})

export default router
```

#### WebSocket客户端管理
```typescript
// composables/useSocket.ts
import { ref, onMounted, onUnmounted } from 'vue'
import { io, Socket } from 'socket.io-client'
import { useUserStore } from '@/stores/user'
import { useGameStore } from '@/stores/game'

export function useSocket() {
  const socket = ref<Socket | null>(null)
  const isConnected = ref(false)
  const reconnectAttempts = ref(0)
  const maxReconnectAttempts = 5
  
  const userStore = useUserStore()
  const gameStore = useGameStore()
  
  const connect = async () => {
    if (socket.value?.connected) return
    
    try {
      socket.value = io(import.meta.env.VITE_WEBSOCKET_URL, {
        transports: ['websocket', 'polling'],
        timeout: 10000,
        auth: {
          token: userStore.accessToken
        }
      })
      
      setupEventListeners()
      
    } catch (error) {
      console.error('WebSocket连接失败:', error)
      handleReconnect()
    }
  }
  
  const disconnect = () => {
    if (socket.value) {
      socket.value.disconnect()
      socket.value = null
      isConnected.value = false
    }
  }
  
  const setupEventListeners = () => {
    if (!socket.value) return
    
    // 连接事件
    socket.value.on('connect', () => {
      console.log('WebSocket已连接')
      isConnected.value = true
      reconnectAttempts.value = 0
      
      // 发送认证信息
      socket.value?.emit('authenticate', userStore.accessToken)
    })
    
    socket.value.on('disconnect', (reason) => {
      console.log('WebSocket断开连接:', reason)
      isConnected.value = false
      
      if (reason === 'io server disconnect') {
        // 服务器主动断开，需要重新连接
        handleReconnect()
      }
    })
    
    socket.value.on('connect_error', (error) => {
      console.error('WebSocket连接错误:', error)
      handleReconnect()
    })
    
    // 认证事件
    socket.value.on('authenticated', (data) => {
      console.log('WebSocket认证成功:', data)
    })
    
    socket.value.on('auth_error', (error) => {
      console.error('WebSocket认证失败:', error)
      userStore.logout()
    })
    
    // 匹配事件
    socket.value.on('match_found', (data) => {
      gameStore.handleMatchFound(data)
    })
    
    socket.value.on('match_cancelled', () => {
      gameStore.handleMatchCancelled()
    })
    
    // 游戏事件
    socket.value.on('game_start', (data) => {
      gameStore.handleGameStart(data)
    })
    
    socket.value.on('answer_result', (data) => {
      gameStore.handleAnswerResult(data)
    })
    
    socket.value.on('game_state_update', (data) => {
      gameStore.handleGameStateUpdate(data)
    })
    
    socket.value.on('level_complete', (data) => {
      gameStore.handleLevelComplete(data)
    })
    
    socket.value.on('game_end', (data) => {
      gameStore.handleGameEnd(data)
    })
    
    // 好友事件
    socket.value.on('friend_online', (data) => {
      userStore.handleFriendOnline(data)
    })
    
    socket.value.on('friend_offline', (data) => {
      userStore.handleFriendOffline(data)
    })
    
    socket.value.on('friend_invite', (data) => {
      userStore.handleFriendInvite(data)
    })
  }
  
  const handleReconnect = () => {
    if (reconnectAttempts.value >= maxReconnectAttempts) {
      console.error('WebSocket重连次数超限')
      return
    }
    
    reconnectAttempts.value++
    const delay = Math.pow(2, reconnectAttempts.value) * 1000 // 指数退避
    
    console.log(`${delay}ms后尝试重连 (第${reconnectAttempts.value}次)`)
    
    setTimeout(() => {
      connect()
    }, delay)
  }
  
  // 发送事件的便捷方法
  const emit = (event: string, data?: any) => {
    if (socket.value?.connected) {
      socket.value.emit(event, data)
    } else {
      console.warn('WebSocket未连接，无法发送事件:', event)
    }
  }
  
  // 加入匹配队列
  const joinMatching = (criteria: MatchCriteria) => {
    emit('join_matching', criteria)
  }
  
  // 离开匹配队列
  const leaveMatching = () => {
    emit('leave_matching')
  }
  
  // 发送答案
  const submitAnswer = (answer: string) => {
    emit('player_answer', { answer })
  }
  
  // 邀请好友
  const inviteFriend = (friendId: string) => {
    emit('friend_invite', { friendId })
  }
  
  onMounted(() => {
    if (userStore.isAuthenticated) {
      connect()
    }
  })
  
  onUnmounted(() => {
    disconnect()
  })
  
  return {
    socket: socket.value,
    isConnected,
    connect,
    disconnect,
    emit,
    joinMatching,
    leaveMatching,
    submitAnswer,
    inviteFriend
  }
}
```

### 8. 性能优化策略

#### 前端性能优化
```typescript
// 1. 代码分割和懒加载
const routes = [
  {
    path: '/battle',
    component: () => import(/* webpackChunkName: "battle" */ '@/views/Battle.vue')
  },
  {
    path: '/shop',
    component: () => import(/* webpackChunkName: "shop" */ '@/views/Shop.vue')
  }
]

// 2. 图片懒加载组件
<template>
  <div class="lazy-image-container">
    <img
      v-if="loaded"
      :src="src"
      :alt="alt"
      @load="onLoad"
      @error="onError"
      class="fade-in"
    />
    <div v-else class="skeleton-loader"></div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue'

interface Props {
  src: string
  alt: string
}

const props = defineProps<Props>()
const loaded = ref(false)

const onLoad = () => {
  loaded.value = true
}

const onError = () => {
  console.error('图片加载失败:', props.src)
}

onMounted(() => {
  // 使用Intersection Observer实现懒加载
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = new Image()
        img.onload = onLoad
        img.onerror = onError
        img.src = props.src
        observer.disconnect()
      }
    })
  })
  
  observer.observe(entry.target)
})
</script>

// 3. 虚拟滚动组件（用于长列表）
<template>
  <div class="virtual-scroll-container" ref="container" @scroll="onScroll">
    <div class="virtual-scroll-spacer" :style="{ height: totalHeight + 'px' }">
      <div
        class="virtual-scroll-items"
        :style="{ transform: `translateY(${offsetY}px)` }"
      >
        <div
          v-for="item in visibleItems"
          :key="item.id"
          class="virtual-scroll-item"
          :style="{ height: itemHeight + 'px' }"
        >
          <slot :item="item" />
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue'

interface Props {
  items: any[]
  itemHeight: number
  containerHeight: number
}

const props = defineProps<Props>()
const container = ref<HTMLElement>()
const scrollTop = ref(0)

const totalHeight = computed(() => props.items.length * props.itemHeight)
const visibleCount = computed(() => Math.ceil(props.containerHeight / props.itemHeight) + 2)
const startIndex = computed(() => Math.floor(scrollTop.value / props.itemHeight))
const endIndex = computed(() => Math.min(startIndex.value + visibleCount.value, props.items.length))
const visibleItems = computed(() => props.items.slice(startIndex.value, endIndex.value))
const offsetY = computed(() => startIndex.value * props.itemHeight)

const onScroll = (event: Event) => {
  scrollTop.value = (event.target as HTMLElement).scrollTop
}
</script>

// 4. 防抖和节流工具
export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout | null = null
  
  return function executedFunction(...args: Parameters<T>) {
    const later = () => {
      timeout = null
      func(...args)
    }
    
    if (timeout) clearTimeout(timeout)
    timeout = setTimeout(later, wait)
  }
}

export function throttle<T extends (...args: any[]) => any>(
  func: T,
  limit: number
): (...args: Parameters<T>) => void {
  let inThrottle: boolean = false
  
  return function executedFunction(...args: Parameters<T>) {
    if (!inThrottle) {
      func(...args)
      inThrottle = true
      setTimeout(() => inThrottle = false, limit)
    }
  }
}
```

#### 后端性能优化
```typescript
// 1. 数据库查询优化
class UserService {
  // 使用索引优化查询
  async getUsersByGrade(grade: string, limit: number = 20) {
    return await this.db.query(`
      SELECT id, nickname, avatar, level, win_rate
      FROM users 
      WHERE grade = $1 AND total_games >= 10
      ORDER BY win_rate DESC, total_games DESC
      LIMIT $2
    `, [grade, limit])
  }
  
  // 批量查询优化
  async getUsersWithFriends(userIds: string[]) {
    return await this.db.query(`
      SELECT 
        u.id, u.nickname, u.avatar,
        COALESCE(
          json_agg(
            json_build_object(
              'id', f.friend_id,
              'nickname', fu.nickname,
              'avatar', fu.avatar,
              'status', f.status
            )
          ) FILTER (WHERE f.friend_id IS NOT NULL),
          '[]'
        ) as friends
      FROM users u
      LEFT JOIN friendships f ON u.id = f.user_id AND f.status = 'accepted'
      LEFT JOIN users fu ON f.friend_id = fu.id
      WHERE u.id = ANY($1)
      GROUP BY u.id, u.nickname, u.avatar
    `, [userIds])
  }
}

// 2. 缓存策略
class CacheService {
  private redis: Redis
  private localCache: Map<string, { data: any, expiry: number }> = new Map()
  
  // 多级缓存
  async get(key: string): Promise<any> {
    // 1. 检查本地缓存
    const localData = this.localCache.get(key)
    if (localData && localData.expiry > Date.now()) {
      return localData.data
    }
    
    // 2. 检查Redis缓存
    const redisData = await this.redis.get(key)
    if (redisData) {
      const data = JSON.parse(redisData)
      // 更新本地缓存
      this.localCache.set(key, {
        data,
        expiry: Date.now() + 60000 // 1分钟本地缓存
      })
      return data
    }
    
    return null
  }
  
  async set(key: string, data: any, ttl: number = 3600) {
    // 同时更新Redis和本地缓存
    await this.redis.setex(key, ttl, JSON.stringify(data))
    this.localCache.set(key, {
      data,
      expiry: Date.now() + Math.min(ttl * 1000, 60000)
    })
  }
  
  // 缓存预热
  async warmupCache() {
    const popularData = [
      'leaderboard:weekly',
      'leaderboard:monthly',
      'achievements:list',
      'shop:items'
    ]
    
    for (const key of popularData) {
      await this.preloadData(key)
    }
  }
}

// 3. 连接池优化
class DatabasePool {
  private pool: Pool
  
  constructor() {
    this.pool = new Pool({
      host: process.env.DB_HOST,
      port: parseInt(process.env.DB_PORT || '5432'),
      database: process.env.DB_NAME,
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,
      min: 5, // 最小连接数
      max: 20, // 最大连接数
      idleTimeoutMillis: 30000, // 空闲超时
      connectionTimeoutMillis: 2000, // 连接超时
    })
  }
  
  async query(text: string, params?: any[]) {
    const start = Date.now()
    const client = await this.pool.connect()
    
    try {
      const result = await client.query(text, params)
      const duration = Date.now() - start
      
      // 记录慢查询
      if (duration > 1000) {
        console.warn(`慢查询 (${duration}ms):`, text)
      }
      
      return result
    } finally {
      client.release()
    }
  }
}

// 4. WebSocket连接优化
class OptimizedSocketServer {
  private io: Server
  private connectionLimiter: Map<string, number> = new Map()
  
  constructor(httpServer: any) {
    this.io = new Server(httpServer, {
      transports: ['websocket', 'polling'],
      pingTimeout: 60000,
      pingInterval: 25000,
      upgradeTimeout: 10000,
      maxHttpBufferSize: 1e6, // 1MB
      compression: true,
      cors: {
        origin: process.env.ALLOWED_ORIGINS?.split(','),
        methods: ['GET', 'POST']
      }
    })
    
    this.setupMiddleware()
  }
  
  private setupMiddleware() {
    // 连接限制中间件
    this.io.use((socket, next) => {
      const ip = socket.handshake.address
      const connections = this.connectionLimiter.get(ip) || 0
      
      if (connections >= 5) { // 每个IP最多5个连接
        next(new Error('连接数超限'))
        return
      }
      
      this.connectionLimiter.set(ip, connections + 1)
      
      socket.on('disconnect', () => {
        const current = this.connectionLimiter.get(ip) || 0
        if (current > 0) {
          this.connectionLimiter.set(ip, current - 1)
        }
      })
      
      next()
    })
    
    // 认证中间件
    this.io.use(async (socket, next) => {
      try {
        const token = socket.handshake.auth.token
        const user = await this.validateToken(token)
        socket.userId = user.id
        socket.userInfo = user
        next()
      } catch (error) {
        next(new Error('认证失败'))
      }
    })
  }
  
  // 批量广播优化
  broadcastToRooms(rooms: string[], event: string, data: any) {
    const serializedData = JSON.stringify(data)
    rooms.forEach(room => {
      this.io.to(room).emit(event, serializedData)
    })
  }
}
```
